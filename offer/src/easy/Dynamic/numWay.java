package easy.Dynamic;

public class numWay {
    /**
     * offer10、青蛙跳台阶问题
     * @param n n个台阶，青蛙一次可条一个也可跳两个
     * @return （求跳法总数）

     * 设跳上 nn 级台阶有 f(n)f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 11 级或 22 级台阶。
     * 当为 11 级台阶： 剩 n-1n−1 个台阶，此情况共有 f(n-1)f(n−1) 种跳法；
     * 当为 22 级台阶： 剩 n-2n−2 个台阶，此情况共有 f(n-2)f(n−2) 种跳法
     *
     * 动态规划
     *动态规划解析：
     * 状态定义： 设 dpdp 为一维数组，其中 dp[i]dp[i] 的值代表 斐波那契数列第 $i$ 个数字 。
     * 转移方程： dp[i + 1] = dp[i] + dp[i - 1]dp[i+1]=dp[i]+dp[i−1] ，即对应数列定义 f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) ；
     * 初始状态： dp[0] = 1dp[0]=1, dp[1] = 1dp[1]=1 ，即初始化前两个数字；
     * 返回值： dp[n]dp[n] ，即斐波那契数列的第 nn 个数字。
     *
     *
     * 空间复杂度优化：
     *
     * 若新建长度为 nn 的 dpdp 列表，则空间复杂度为 O(N)O(N) 。
     *
     * 由于 dpdp 列表第 ii 项只与第 i-1i−1 和第 i-2i−2 项有关，因此只需要初始化三个整形变量 sum, a, b ，利用辅助变量 sumsum 使 a, ba,b 两数字交替前进即可 （具体实现见代码） 。
     * 因为节省了 dpdp 列表空间，因此空间复杂度降至 O(1)O(1) 。
     */
    public int numWays(int n) {
        int a = 1, b = 1, sum; //0层、一层台阶为一种跳法
        for(int i = 0; i < n; i++){
            sum = (a + b) % 1000000007; //dp[n+1]
            a = b; //dp[n]
            b = sum; //dp[n-1]
        }
        return a;
    }
}
